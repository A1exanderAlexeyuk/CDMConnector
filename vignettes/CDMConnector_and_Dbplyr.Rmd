---
title: "CDMConnector and dbplyr"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{CDMConnector and dbplyr}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval = FALSE
)
```

## Set up

First let's load the required packages for the code in this vignette. If you haven't already installed them, all the other packages can be installed using ´install.packages()´ 

```{r, message=FALSE, warning=FALSE}
library(CDMConnector)
library(dplyr, warn.conflicts = FALSE)
library(ggplot2)
```

## Creating the cdm reference

Now let´s connect to a duckdb database with the Eunomia data (https://github.com/OHDSI/Eunomia).

```{r, message=FALSE, warning=FALSE}
con <- DBI::dbConnect(duckdb::duckdb(), dbdir = eunomia_dir())
cdm <- cdm_from_con(con, cdm_schema = "main")
cdm
```


This cdm object is now what we´ll use going forward. It provides a reference to the OMOP CDM tables. We can see that these tables are still in the database, but now we have a reference to each of the ones we might want to use in our analysis. For example, the person table can be referenced like so


```{r, message=FALSE, warning=FALSE}
cdm$person
```

The observation table with
```{r, message=FALSE, warning=FALSE}
cdm$observation_period
```

And so on, with the cdm object behaving like a named list of tables.  



## Using familiar Dplyr verbs

With our data left in the database, we can still use some of what may well be familiar dplyr verbs (https://dplyr.tidyverse.org/articles/dplyr.html) using the dbplyr backend (https://dbplyr.tidyverse.org/), which converts familiar dplyr code into SQL.

So we can use `summarise` to get the median year of birth in the person table.

```{r, warning=FALSE}
cdm$person %>% 
  summarise(median(year_of_birth)) 
```

We can use mutate to create a flag of "Male"/ "Female" based on the gender_concept_id in the person table.

```{r, warning=FALSE}
cdm$person %>%
    mutate(gender = ifelse(gender_concept_id == "8507", "Male",
      ifelse(gender_concept_id == "8532", "Female", NA)
    )) %>% 
  select("person_id","gender_concept_id", "gender") %>% 
  head(10)
```

The filter command lets us subset the condition occurrence table to only those records with a specific condition_concept_id. In this case, 317009 is a standard code for asthma (https://athena.ohdsi.org/search-terms/terms/317009)

```{r, warning=FALSE}
cdm$condition_occurrence %>%
  filter(condition_concept_id == 317009) 
```
  
And we can can also use joins to merge tables of interest, such as a `left_join` between the person and observation_period tables.

```{r}
cdm$person  %>%
  select(person_id , gender_concept_id, year_of_birth) %>% 
  left_join(cdm$observation_period  %>% 
              select(person_id, observation_period_start_date,
                     observation_period_end_date),
            by="person_id")

```

It is worth noting that not all dplyr verbs are supported by dplyr, and some are only supported for some database management systems. For example let´s see what happens if we try and use `slice` to subset rows using their positions.

```{r, error=TRUE}
cdm$person %>% slice(1:5)
```

This is an example of a verb that would only work if we had the data in memory.

## Compute and collect

We can split multiple queries by running `compute` (to store information in temporary tables). For example, we can first find occurrences of asthma.

```{r}
asthma_occurrences <- cdm$condition_occurrence %>%
  filter(condition_concept_id == 317009) 

asthma_occurrences
```

And then run multiple queries against the result
```{r}
# count of rows
asthma_occurrences %>%
  tally()

# count of people
asthma_occurrences %>%
  select(person_id) %>%
  distinct() %>%
  tally()
```

We can split also bring the results into memory in R with `collect`

```{r }
asthma_occurrences<-cdm$condition_occurrence %>%
  filter(condition_concept_id == 317009) %>% 
  collect() 

# now asthma_occurrences is in memory
str(asthma_occurrences)
```


## Putting it all together

Say we want to make a histogram of year of birth in the person table. We can select that variable, bring it into memory, and then use ggplot to make the histogram.

```{r, message=FALSE}
cdm$person %>% 
  select(year_of_birth) %>%
  collect() %>% 
  ggplot() +
  geom_histogram(aes(year_of_birth))
```

If we wanted to make a boxplot for length of observation periods we could do the compuatiton on the database side, bring in the new variable into memory, and use ggplot to produce the boxplot
```{r}
cdm$observation_period %>%
  select(observation_period_start_date, observation_period_end_date) %>%
  mutate(observation_period = (observation_period_end_date - observation_period_start_date)/365,25) %>%
  select(observation_period) %>% 
  collect() %>%
  ggplot() +
  geom_boxplot(aes(observation_period))
```


## Behind the scenes
We use show_query to check the sql that is being run against duckdb
```{r}
cdm$person %>% 
  tally() %>% 
  show_query()
```

```{r}
cdm$person %>% 
  summarise(median(year_of_birth))%>% 
  show_query() 
```

```{r, warning=FALSE}
cdm$person %>%
    mutate(gender = ifelse(gender_concept_id == "8507", "Male",
      ifelse(gender_concept_id == "8532", "Female", NA)
    ))%>% 
  show_query() 
```

But that´s specific to duckdb, what would this look like for other database management systems? Below we can see what these queries would look like on postgres, redshift, and snowflake.

```{r}
person<-cdm$person %>% collect()

dbplyr::tbl_lazy(person, con = dbplyr::simulate_postgres()) %>% 
  tally()
dbplyr::tbl_lazy(person, con = dbplyr::simulate_postgres()) %>% 
  summarise(median(year_of_birth))
dbplyr::tbl_lazy(person, con = dbplyr::simulate_postgres()) %>% 
  mutate(gender = ifelse(gender_concept_id == "8507", "Male",
      ifelse(gender_concept_id == "8532", "Female", NA)
    ))

dbplyr::tbl_lazy(person, con = dbplyr::simulate_redshift()) %>% 
  tally()
dbplyr::tbl_lazy(person, con = dbplyr::simulate_redshift()) %>% 
  summarise(median(year_of_birth))
dbplyr::tbl_lazy(person, con = dbplyr::simulate_redshift()) %>% 
  mutate(gender = ifelse(gender_concept_id == "8507", "Male",
      ifelse(gender_concept_id == "8532", "Female", NA)
    ))

dbplyr::tbl_lazy(person, con = dbplyr::simulate_snowflake()) %>% 
  tally()
dbplyr::tbl_lazy(person, con = dbplyr::simulate_snowflake()) %>% 
  summarise(median(year_of_birth))
dbplyr::tbl_lazy(person, con = dbplyr::simulate_snowflake()) %>% 
  mutate(gender = ifelse(gender_concept_id == "8507", "Male",
      ifelse(gender_concept_id == "8532", "Female", NA)
    ))
```

```{r}
DBI::dbDisconnect(con, disconnect = TRUE)
```

<div style="margin-bottom:3cm;"></div>
